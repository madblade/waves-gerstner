(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{5:function(e,n,t){"use strict";t.r(n);var o=t(0);function a(e,n){var t=1.5/Math.pow(e,2),o=(.002+(e-1)/n*.18)/.06;return{steepness:(e+2)/(n+2),speed:2*(e+1)/n,angle:e*Math.PI*2/n,frequency:o,amplitude:t}}var i=function(e,n){o.n.call(this,e);var t=this,i=void 0!==(n=n||{}).textureWidth?n.textureWidth:512,r=void 0!==n.textureHeight?n.textureHeight:512,l=void 0!==n.clipBias?n.clipBias:0,s=void 0!==n.alpha?n.alpha:1,c=void 0!==n.time?n.time:0,u=void 0!==n.waterNormals?n.waterNormals:null,d=void 0!==n.sunDirection?n.sunDirection:new o.C(.70707,.70707,0),v=new o.c(void 0!==n.sunColor?n.sunColor:16777215),f=new o.c(void 0!==n.waterColor?n.waterColor:8355711),m=void 0!==n.eye?n.eye:new o.C(0,0,0),p=void 0!==n.side?n.side:o.h,g=void 0!==n.fog&&n.fog,h=void 0!==n.direction?n.direction:0,x=void 0!==n.frequency?n.frequency:.05,w=void 0!==n.amplitude?n.amplitude:20,y=void 0!==n.steepness?n.steepness:1,C=void 0!==n.speed?n.speed:1,I=void 0!==n.manyWaves&&n.manyWaves,S=new o.q,b=new o.C,M=new o.C,P=new o.C,E=new o.m,D=new o.C(0,0,-1),z=new o.D,T=new o.C,_=new o.C,A=new o.D,W=new o.m,R=new o.p,N={minFilter:o.i,magFilter:o.i,format:o.t,stencilBuffer:!1},B=new o.E(i,r,N);o.l.isPowerOfTwo(i)&&o.l.isPowerOfTwo(r)||(B.texture.generateMipmaps=!1);var F=function(){for(var e=new Uint8Array(192),n=0,t=0;n<192;){var i=a(++t,64);e[n++]=255*i.steepness,e[n++]=255*i.speed,e[n++]=0,e[n++]=255*i.angle,e[n++]=255*i.frequency,e[n++]=255*i.amplitude}var r=new o.e(e,8,8,o.t);return r.generateMipmaps=!1,r.minFilter=o.o,r.magFilter=o.o,r.wrapT=o.u,r.wrapS=o.u,r}(),q={uniforms:o.A.merge([o.z.fog,o.z.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:2.7},textureMatrix:{value:new o.m},sunColor:{value:new o.c(8355711)},sunDirection:{value:new o.C(.70707,.70707,0)},eye:{value:new o.C},waterColor:{value:new o.c(5592405)},direction:{value:h},frequency:{value:x},amplitude:{value:w},steepness:{value:y},speed:{value:C},wavesToAdd:{value:I},coefficientSampler:{value:F}}]),vertexShader:"\n            #include <common>\n            ".concat("// Approach reference\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models\n\n// Normal textures\nuniform mat4 textureMatrix;\n\n// User-specified first wave\nuniform float direction;\nuniform float frequency;\nuniform float amplitude;\nuniform float steepness;\nuniform float speed;\n\n// Additional coefficients stored in texture\nuniform int wavesToAdd;\nuniform sampler2D coefficientSampler;\n\n// Simulation step\nuniform float time;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvarying vec3 vvnormal;\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nconst int NB_WAVES = 16;\n\nvoid addWave(\n    float x, float y,\n    float frequencyI, float amplitudeI, float steepnessI, float directionI, float phaseI,\n    inout vec3 o, bool doIt\n)\n{\n    if (!doIt) return;\n    vec2 d = vec2(cos(directionI), sin(directionI));\n    float s = steepnessI / (clamp(amplitudeI, 0.01, 1e7) * frequencyI);\n    float sa = s * amplitudeI;\n    float fdotpht = frequencyI * dot(d, vec2(x, y)) + phaseI * time;\n    float sacf = sa * cos(fdotpht);\n    o.x += d.x * sacf;\n    o.y += d.y * sacf;\n    o.z += amplitudeI * sin(fdotpht);\n}\n\nvoid addWaveNormal(\n    float x, float y,\n    float frequencyI, float amplitudeI, float steepnessI, float directionI, float phaseI,\n    vec3 p, inout vec3 n, bool doIt\n)\n{\n    if (!doIt) return;\n    vec2 d = vec2(cos(directionI), sin(directionI));\n    float s = steepnessI / (clamp(amplitudeI, 0.01, 1e7) * frequencyI);\n    float fa = frequencyI * amplitudeI;\n    float fdpt = frequencyI * dot(vec3(d, 0.0), p) + phaseI * time;\n    float facf = fa * cos(fdpt);\n    n.x -= (d.x * facf );\n    n.y -= (d.y * facf );\n    n.z -= (s * fa * sin(fdpt) );\n}\n\nvec3 gerstnerPositions(float x, float y)\n{\n    vec3 o = vec3(x, y, 0.0);\n\n    addWave(x, y, frequency, amplitude, steepness, direction, speed, o, wavesToAdd < 1);\n\n    float tx = 0.0; float ty = 0.0;\n    for (int i = 0; i < NB_WAVES; i++)\n    {\n        if (i >= wavesToAdd) break;\n        tx++; if (tx > 7.0) { tx = 0.0; ty++; }\n        vec4 rgb1 = texture2D(coefficientSampler, vec2(tx + 0.01, ty + 0.01) / 8.0);\n        tx++; if (tx > 7.0) { tx = 0.0; ty++; }\n        vec4 rgb2 = texture2D(coefficientSampler, vec2(tx + 0.01, ty + 0.01) / 8.0);\n        float directionI = float(rgb1.r) * 2.0 * 3.1415;\n        float frequencyI = float(rgb1.g) * 0.4;\n        float amplitudeI = float(rgb1.b) * 40.0;\n        float steepnessI = float(rgb2.r) * 1.0;\n        float phaseI     = float(rgb2.g) * 5.0;\n        addWave(x, y, frequencyI, amplitudeI, steepnessI, directionI, phaseI, o, true); // i == wavesToAdd - 1);\n    }\n\n    return o;\n}\n\nvec3 gerstnerNormals(float x, float y, vec3 p)\n{\n    vec3 n = vec3(0.0, 0.0, 1.0);\n\n    addWaveNormal(x, y, frequency, amplitude, steepness, direction, speed, p, n, wavesToAdd < 1);\n\n    float tx = 0.0; float ty = 0.0;\n    for (int i = 0; i < NB_WAVES; i++)\n    {\n        if (i >= wavesToAdd) break;\n        tx++; if (tx > 7.0) { tx = 0.0; ty++; }\n        vec4 rgb1 = texture2D(coefficientSampler, vec2(tx + 0.01, ty + 0.01) / 8.0);\n        tx++; if (tx > 7.0) { tx = 0.0; ty++; }\n        vec4 rgb2 = texture2D(coefficientSampler, vec2(tx + 0.01, ty + 0.01) / 8.0);\n        float directionI = float(rgb1.r) * 2.0 * 3.1415;\n        float frequencyI = float(rgb1.g) * 0.1;\n        float amplitudeI = float(rgb1.b) * 40.0;\n        float steepnessI = float(rgb2.r) * 1.0;\n        float phaseI     = float(rgb2.g) * 5.0;\n        addWaveNormal(x, y, frequencyI, amplitudeI, steepnessI, directionI, phaseI, p, n, true); // i == wavesToAdd - 1);\n    }\n\n    return n;\n}\n\nvoid main()\n{\n    mirrorCoord = modelMatrix * vec4( position, 1.0 );\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n    vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\n    // this is how to use gerstner\n    vec3 newPo = gerstnerPositions(position.x, position.y);\n    vec3 gn = gerstnerNormals(position.x, position.y, newPo);\n    vvnormal = normalMatrix * gn;\n    mvPosition = modelViewMatrix * vec4(newPo.x, newPo.y, newPo.z, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n}\n","\n        "),fragmentShader:"\n            #include <common>\n            ".concat("uniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\nvarying vec3 vvnormal;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nvec4 getNoise(vec2 uv)\n{\n    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0);\n    vec2 uv2 = uv / vec2(890.70, 980.30) + vec2(time / 101.0, time / 97.0);\n    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\n    vec4 noise = texture2D(normalSampler, uv0) +\n    texture2D(normalSampler, uv1) +\n    texture2D(normalSampler, uv2) +\n    texture2D(normalSampler, uv3);\n\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight(\nconst vec3 surfaceNormal, const vec3 eyeDirection,\nfloat shiny, float spec, float diffuse,\ninout vec3 diffuseColor, inout vec3 specularColor)\n{\n    vec3 reflection = normalize( reflect(-sunDirection, surfaceNormal) );\n    float direction = max( 0.0, dot(eyeDirection, reflection) );\n    specularColor += pow(abs(direction), shiny) * sunColor * spec;\n    diffuseColor += max( dot(sunDirection, surfaceNormal), 0.0 ) * sunColor * diffuse;\n}\n\n    #include <packing>\n    #include <bsdfs>\n    #include <fog_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <lights_pars_begin>\n    #include <shadowmap_pars_fragment>\n    #include <shadowmask_pars_fragment>\n\nvoid main() {\n\n    #include <logdepthbuf_fragment>\n    vec4 noise = getNoise( worldPosition.xz * size );\n//    \tvec3 surfaceNormal = normalize(vvnormal); //normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) ); // this for gerstner\n    \tvec3 surfaceNormal = normalize( vvnormal + noise.xzy * vec3( 1.5, 1.0, 1.5 ) ); // this for mix\n//      vec3 surfaceNormal = normalize( noise.xyz * vec3( 1.5, 1.0, 1.5 ) ); // this for texture\n\n    vec3 diffuseLight = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n\n    vec3 worldToEye = eye - worldPosition.xyz;\n    vec3 eyeDirection = normalize( worldToEye );\n    sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n    float distance = length(worldToEye);\n\n    vec2 distortion = vec2(0);\n    vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w) );\n\n    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n    float rf0 = 0.3;\n    float reflectance = rf0 + ( 1.0 - rf0 ) * pow( abs( 1.0 - theta ), 5.0 );\n    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n    vec3 albedo = mix(\n        ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(),\n        ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ),\n        reflectance\n    );\n    vec3 outgoingLight = albedo;\n    gl_FragColor = vec4( outgoingLight, alpha );\n\n    #include <tonemapping_fragment>\n    #include <fog_fragment>\n}\n","\n        ")},L=new o.w({fragmentShader:q.fragmentShader,vertexShader:q.vertexShader,uniforms:o.A.clone(q.uniforms),lights:!0,side:p,fog:g});L.uniforms.mirrorSampler.value=B.texture,L.uniforms.textureMatrix.value=W,L.uniforms.alpha.value=s,L.uniforms.time.value=c,L.uniforms.normalSampler.value=u,L.uniforms.sunColor.value=v,L.uniforms.waterColor.value=f,L.uniforms.sunDirection.value=d,L.uniforms.eye.value=m,t.material=L,t.onBeforeRender=function(e,n,o){if(M.setFromMatrixPosition(t.matrixWorld),P.setFromMatrixPosition(o.matrixWorld),E.extractRotation(t.matrixWorld),b.set(0,0,1),b.applyMatrix4(E),T.subVectors(M,P),!(T.dot(b)>0)){T.reflect(b).negate(),T.add(M),E.extractRotation(o.matrixWorld),D.set(0,0,-1),D.applyMatrix4(E),D.add(P),_.subVectors(M,D),_.reflect(b).negate(),_.add(M),R.position.copy(T),R.up.set(0,1,0),R.up.applyMatrix4(E),R.up.reflect(b),R.lookAt(_),R.far=o.far,R.updateMatrixWorld(),R.projectionMatrix.copy(o.projectionMatrix),W.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),W.multiply(R.projectionMatrix),W.multiply(R.matrixWorldInverse),S.setFromNormalAndCoplanarPoint(b,M),S.applyMatrix4(R.matrixWorldInverse),z.set(S.normal.x,S.normal.y,S.normal.z,S.constant);var a=R.projectionMatrix;A.x=(Math.sign(z.x)+a.elements[8])/a.elements[0],A.y=(Math.sign(z.y)+a.elements[9])/a.elements[5],A.z=-1,A.w=(1+a.elements[10])/a.elements[14],z.multiplyScalar(2/z.dot(A)),a.elements[2]=z.x,a.elements[6]=z.y,a.elements[10]=z.z+1-l,a.elements[14]=z.w,m.setFromMatrixPosition(o.matrixWorld);var i=e.getRenderTarget(),r=e.xr.enabled,s=e.shadowMap.autoUpdate;t.visible=!1,e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(B),!1===e.autoClear&&e.clear(),e.render(n,R),t.visible=!0,e.xr.enabled=r,e.shadowMap.autoUpdate=s,e.setRenderTarget(i);var c=o.viewport;void 0!==c&&e.state.viewport(c)}}};(i.prototype=Object.create(o.n.prototype)).constructor=i;var r=function e(){var n=e.SkyShader,t=new o.w({fragmentShader:n.fragmentShader,vertexShader:n.vertexShader,uniforms:o.A.clone(n.uniforms),side:o.a,depthWrite:!1});o.n.call(this,new o.b(1,1,1),t)};r.prototype=Object.create(o.n.prototype),r.SkyShader={uniforms:{luminance:{value:1},turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.C},up:{value:new o.C(0,1,0)}},vertexShader:["uniform vec3 sunPosition;","uniform float rayleigh;","uniform float turbidity;","uniform float mieCoefficient;","uniform vec3 up;","varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","const float e = 2.71828182845904523536028747135266249775724709369995957;","const float pi = 3.141592653589793238462643383279502884197169;","const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );","const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );","const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );","const float cutoffAngle = 1.6110731556870734;","const float steepness = 1.5;","const float EE = 1000.0;","float sunIntensity( float zenithAngleCos ) {","\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );","\treturn EE * max( 0.0, 1.0 - pow( abs(e), -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );","}","vec3 totalMie( float T ) {","\tfloat c = ( 0.2 * T ) * 10E-18;","\treturn 0.434 * c * MieConst;","}","void main() {","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvWorldPosition = worldPosition.xyz;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","\tgl_Position.z = gl_Position.w;","\tvSunDirection = normalize( sunPosition );","\tvSunE = sunIntensity( dot( vSunDirection, up ) );","\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );","\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );","\tvBetaR = totalRayleigh * rayleighCoefficient;","\tvBetaM = totalMie( turbidity ) * mieCoefficient;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","uniform float luminance;","uniform float mieDirectionalG;","uniform vec3 up;","const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );","const float pi = 3.141592653589793238462643383279502884197169;","const float rayleighZenithLength = 8.4E3;","const float mieZenithLength = 1.25E3;","const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;","const float THREE_OVER_SIXTEENPI = 0.05968310365946075;","const float ONE_OVER_FOURPI = 0.07957747154594767;","float rayleighPhase( float cosTheta ) {","\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( abs(cosTheta), 2.0 ) );","}","float hgPhase( float cosTheta, float g ) {","\tfloat g2 = pow( abs(g), 2.0 );","\tfloat inverse = 1.0 / pow( abs(1.0 - 2.0 * g * cosTheta + g2), 1.5 );","\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );","}","const float A = 0.15;","const float B = 0.50;","const float C = 0.10;","const float D = 0.20;","const float E = 0.02;","const float F = 0.30;","const float whiteScale = 1.0748724675633854;","vec3 Uncharted2Tonemap( vec3 x ) {","\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;","}","void main() {","\tvec3 direction = normalize( vWorldPosition - cameraPos );","\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );","\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( abs(93.885 - ( ( zenithAngle * 180.0 ) / pi )), -1.253 ) );","\tfloat sR = rayleighZenithLength * inverse;","\tfloat sM = mieZenithLength * inverse;","\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );","\tfloat cosTheta = dot( direction, vSunDirection );","\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );","\tvec3 betaRTheta = vBetaR * rPhase;","\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );","\tvec3 betaMTheta = vBetaM * mPhase;","\tvec3 Lin = pow( abs(vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex )), vec3( 1.5 ) );","\tLin *= mix( vec3( 1.0 ), pow( abs(vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex),       vec3( 1.0 / 2.0 ) ), clamp( pow( abs(1.0 - dot( up, vSunDirection )), 5.0 ), 0.0, 1.0 ) );","\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]","\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]","\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );","\tvec3 L0 = vec3( 0.1 ) * Fex;","\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );","\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;","\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );","\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( abs(luminance), 4.0 ) ) ) * texColor );","\tvec3 color = curr * whiteScale;","\tvec3 retColor = pow( abs(color), vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );","\tgl_FragColor = vec4( retColor, 1.0 );","}"].join("\n")};var l,s,c,u,d,v,f,m,p=t(4),g=t.p+"ce665323792b2c9bd48d3b9796c287dd.jpg",h=t(1),x=t(2),w=t(3);function y(){c.aspect=window.innerWidth/window.innerHeight,c.updateProjectionMatrix(),d.setSize(window.innerWidth,window.innerHeight)}!function(){l=document.getElementById("container"),(d=new o.F({antialias:!0})).setPixelRatio(window.devicePixelRatio),d.setSize(window.innerWidth,window.innerHeight),l.appendChild(d.domElement),u=new o.v,(c=new o.p(45,window.innerWidth/window.innerHeight,1,2e4)).position.set(0,100,400),v=new o.f(16777215,.8),u.add(v);var e=new o.r(500,500,200,200);(m=new i(e,{textureWidth:512,textureHeight:512,waterNormals:(new p.a).load(g,(function(e){e.wrapS=e.wrapT=o.u})),alpha:1,sunDirection:v.position.clone().normalize(),sunColor:16777215,waterColor:61183,direction:0,frequency:.05,amplitude:20,steepness:.7,speed:1,manyWaves:0})).rotation.x=-Math.PI/2,u.add(m);var n=new r,t=n.material.uniforms;t.turbidity.value=10,t.rayleigh.value=2,t.luminance.value=1,t.mieCoefficient.value=.005,t.mieDirectionalG.value=.8;var a={distance:400,inclination:.3,azimuth:.205},C=new o.d(.1,1,512);function I(){var e=Math.PI*(a.inclination-.5),t=2*Math.PI*(a.azimuth-.5);v.position.x=a.distance*Math.cos(t),v.position.y=a.distance*Math.sin(t)*Math.sin(e),v.position.z=a.distance*Math.sin(t)*Math.cos(e),n.material.uniforms.sunPosition.value=v.position.copy(v.position),m.material.uniforms.sunDirection.value.copy(v.position).normalize(),C.update(d,n)}C.renderTarget.texture.generateMipmaps=!0,C.renderTarget.texture.minFilter=o.j,u.background=C.renderTarget,I(),(f=new h.a(c,d.domElement)).maxPolarAngle=.495*Math.PI,f.target.set(0,0,0),f.minDistance=40,f.maxDistance=1e3,f.update(),s=new x.a,l.appendChild(s.dom);var S=new w.a,b=S.addFolder("Sky");b.add(a,"inclination",0,.5,1e-4).onChange(I),b.add(a,"azimuth",0,1,1e-4).onChange(I),t=m.material.uniforms,(b=S.addFolder("Water")).add(t.direction,"value",0,2*Math.PI,.01).name("wave angle"),b.add(t.frequency,"value",.01,.08,.001).name("frequency"),b.add(t.amplitude,"value",0,40,.5).name("amplitude"),b.add(t.steepness,"value",0,1,.01).name("steepness"),b.add(t.speed,"value",0,5,.01).name("speed"),b.add(t.wavesToAdd,"value",0,16,1).name("add waves"),b.open(),window.addEventListener("resize",y,!1)}(),function e(){requestAnimationFrame(e),m.material.uniforms.time.value+=1/120,d.render(u,c),s.update()}()}},[[5,1,2]]]);